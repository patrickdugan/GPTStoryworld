<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Storyworld Manifold + DAG + Endings</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body { margin: 0; padding: 0; height: 100%; background: #05060a; overflow: hidden; }
    #ui {
      position: fixed; top: 12px; left: 12px;
      color: #cfd6ff; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      font-size: 12px; letter-spacing: 0.2px;
      background: rgba(8, 10, 18, 0.45);
      border: 1px solid rgba(140, 160, 255, 0.15);
      padding: 10px 12px; border-radius: 10px;
      backdrop-filter: blur(6px);
      user-select: none;
    }
    #ui b { color: #ffffff; font-weight: 600; }
    #ui .hint { opacity: 0.75; margin-top: 6px; }
  </style>

  <!--
    If you'd rather use a local three install, replace the importmap paths with:
      "./node_modules/three/build/three.module.js"
      "./node_modules/three/examples/jsm/controls/OrbitControls.js"
  -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>
</head>
<body>
  <div id="ui">
    <b>Storyworld as a 3-Variable Manifold</b><br/>
    Manifold surface = emergent narrative space<br/>
    Central DAG = encounter/spool structure<br/>
    Colored nodes = endings embedded in latent volume
    <div class="hint">
      Drag: orbit · Scroll: zoom · Right-drag: pan
    </div>
  </div>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";

    // -----------------------------
    // Scene / Renderer / Camera
    // -----------------------------
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x05060a, 0.035);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    document.body.appendChild(renderer.domElement);

    const camera = new THREE.PerspectiveCamera(
      55,
      window.innerWidth / window.innerHeight,
      0.1,
      200
    );
    camera.position.set(0, 7.5, 16);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.06;
    controls.minDistance = 6;
    controls.maxDistance = 40;

    // -----------------------------
    // Lighting
    // -----------------------------
    const ambient = new THREE.AmbientLight(0x9aa7ff, 0.22);
    scene.add(ambient);

    const key = new THREE.DirectionalLight(0xffffff, 0.85);
    key.position.set(6, 10, 4);
    scene.add(key);

    const rim = new THREE.DirectionalLight(0x7aa2ff, 0.35);
    rim.position.set(-8, 6, -10);
    scene.add(rim);

    const point = new THREE.PointLight(0x9db3ff, 0.8, 80);
    point.position.set(0, 2.5, 0);
    scene.add(point);

    // -----------------------------
    // Starfield
    // -----------------------------
    function makeStarfield(count = 1200) {
      const geo = new THREE.BufferGeometry();
      const positions = new Float32Array(count * 3);
      const range = 60;

      for (let i = 0; i < count; i++) {
        const i3 = i * 3;
        positions[i3 + 0] = (Math.random() - 0.5) * range;
        positions[i3 + 1] = (Math.random() - 0.5) * range;
        positions[i3 + 2] = (Math.random() - 0.5) * range;
      }

      geo.setAttribute("position", new THREE.BufferAttribute(positions, 3));
      const mat = new THREE.PointsMaterial({
        size: 0.06,
        color: 0xaab6ff,
        transparent: true,
        opacity: 0.6,
        depthWrite: false
      });

      return new THREE.Points(geo, mat);
    }
    scene.add(makeStarfield());

    // -----------------------------
    // Axes + subtle grid
    // -----------------------------
    const axes = new THREE.AxesHelper(6);
    axes.material.transparent = true;
    axes.material.opacity = 0.65;
    scene.add(axes);

    const grid = new THREE.GridHelper(14, 28, 0x223366, 0x111827);
    grid.position.y = -1.8;
    grid.material.transparent = true;
    grid.material.opacity = 0.25;
    scene.add(grid);

    // Axis labels (simple sprites)
    function textSprite(text) {
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      const scale = 2;
      canvas.width = 256 * scale;
      canvas.height = 128 * scale;

      ctx.fillStyle = "rgba(0,0,0,0)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.font = `${48 * scale}px system-ui, sans-serif`;
      ctx.fillStyle = "#dfe6ff";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(text, canvas.width / 2, canvas.height / 2);

      const tex = new THREE.CanvasTexture(canvas);
      tex.colorSpace = THREE.SRGBColorSpace;

      const mat = new THREE.SpriteMaterial({
        map: tex,
        transparent: true,
        depthWrite: false,
        opacity: 0.9
      });
      const spr = new THREE.Sprite(mat);
      spr.scale.set(2.2, 1.1, 1);
      return spr;
    }

    const labelX = textSprite("Var X (Agency)");
    labelX.position.set(6.5, 0.2, 0);
    scene.add(labelX);

    const labelY = textSprite("Var Y (Trust)");
    labelY.position.set(0, 6.2, 0);
    scene.add(labelY);

    const labelZ = textSprite("Var Z (Scarcity)");
    labelZ.position.set(0, 0.2, 6.5);
    scene.add(labelZ);

    // -----------------------------
    // Manifold Surface
    // -----------------------------
    // A wavy sheet suggesting a latent narrative manifold.
    // We build a plane and displace vertices.
    const manifoldGroup = new THREE.Group();
    scene.add(manifoldGroup);

    const size = 10;
    const segments = 140;

    const planeGeo = new THREE.PlaneGeometry(size, size, segments, segments);
    planeGeo.rotateX(-Math.PI / 2);

    // Displace vertices to form a "moral/narrative curvature"
    const pos = planeGeo.attributes.position;
    for (let i = 0; i < pos.count; i++) {
      const x = pos.getX(i);
      const z = pos.getZ(i);
      // "Story tension" field: layered waves + gentle basin
      const wave =
        0.55 * Math.sin(0.9 * x) * Math.cos(0.8 * z) +
        0.25 * Math.sin(0.35 * (x + z)) +
        0.18 * Math.cos(0.45 * (x - 1.2 * z));
      const basin = -0.015 * (x * x + z * z);
      const y = wave + basin;
      pos.setY(i, y);
    }
    pos.needsUpdate = true;
    planeGeo.computeVertexNormals();

    const manifoldMat = new THREE.MeshStandardMaterial({
      color: 0x1b2555,
      metalness: 0.15,
      roughness: 0.35,
      transparent: true,
      opacity: 0.32,
      side: THREE.DoubleSide,
      emissive: 0x0a1133,
      emissiveIntensity: 0.35
    });

    const manifoldMesh = new THREE.Mesh(planeGeo, manifoldMat);
    manifoldMesh.position.y = 0.15;
    manifoldGroup.add(manifoldMesh);

    // A thin wireframe overlay for extra "math vibes"
    const wire = new THREE.LineSegments(
      new THREE.WireframeGeometry(planeGeo),
      new THREE.LineBasicMaterial({
        color: 0x6a86ff,
        transparent: true,
        opacity: 0.12
      })
    );
    wire.position.copy(manifoldMesh.position);
    manifoldGroup.add(wire);

    // -----------------------------
    // Central DAG
    // -----------------------------
    // We'll place the DAG roughly at the center, slightly above the surface.
    const dagGroup = new THREE.Group();
    scene.add(dagGroup);

    // Node layout for a small directed acyclic structure
    const dagNodes = [
      { id: "S0", p: new THREE.Vector3(0, 1.6, 0) },

      { id: "E1", p: new THREE.Vector3(-1.8, 1.2, -1.2) },
      { id: "E2", p: new THREE.Vector3(0.0,  1.1, -1.8) },
      { id: "E3", p: new THREE.Vector3(1.8,  1.2, -1.2) },

      { id: "M1", p: new THREE.Vector3(-2.2, 0.7,  0.9) },
      { id: "M2", p: new THREE.Vector3(0.0,  0.6,  1.4) },
      { id: "M3", p: new THREE.Vector3(2.2,  0.7,  0.9) },

      { id: "C1", p: new THREE.Vector3(-1.2, 0.2,  2.6) },
      { id: "C2", p: new THREE.Vector3(1.2,  0.2,  2.6) }
    ];

    const dagEdges = [
      ["S0", "E1"], ["S0", "E2"], ["S0", "E3"],
      ["E1", "M1"], ["E2", "M2"], ["E3", "M3"],
      ["M1", "C1"], ["M2", "C1"], ["M2", "C2"], ["M3", "C2"]
    ];

    const nodeMatCore = new THREE.MeshStandardMaterial({
      color: 0xe8ecff,
      emissive: 0x536bff,
      emissiveIntensity: 0.55,
      roughness: 0.25,
      metalness: 0.1
    });

    const nodeGeom = new THREE.SphereGeometry(0.12, 22, 22);
    const dagNodeMeshes = new Map();

    for (const n of dagNodes) {
      const m = new THREE.Mesh(nodeGeom, nodeMatCore.clone());
      m.position.copy(n.p);
      dagGroup.add(m);
      dagNodeMeshes.set(n.id, m);

      // glow sprite
      const spr = makeGlowSprite(0x8aa2ff, 0.55, 0.55);
      spr.position.copy(n.p);
      dagGroup.add(spr);
    }

    // Edge lines
    const edgeMat = new THREE.LineBasicMaterial({
      color: 0x8aa2ff,
      transparent: true,
      opacity: 0.45
    });

    for (const [a, b] of dagEdges) {
      const pa = dagNodeMeshes.get(a).position;
      const pb = dagNodeMeshes.get(b).position;

      const g = new THREE.BufferGeometry().setFromPoints([pa, pb]);
      const line = new THREE.Line(g, edgeMat);
      dagGroup.add(line);

      // tiny "direction hint" bead closer to target
      const bead = new THREE.Mesh(
        new THREE.SphereGeometry(0.035, 12, 12),
        new THREE.MeshStandardMaterial({
          color: 0x9fb0ff,
          emissive: 0x9fb0ff,
          emissiveIntensity: 0.8
        })
      );
      bead.position.copy(pa).lerp(pb, 0.72);
      dagGroup.add(bead);
    }

    // -----------------------------
    // Endings embedded in manifold volume
    // -----------------------------
    const endingsGroup = new THREE.Group();
    scene.add(endingsGroup);

    const endingColors = [
      0xff6bd6, 0x6bffdf, 0xffb86b, 0x8b6bff, 0x6bff7a, 0xff6b6b
    ];

    // Sample points "inside" the volume bounded by the manifold surface
    // We'll place them near the center area with slight vertical offsets
    const endingPositions = [
      new THREE.Vector3(-2.6, 0.35, -0.6),
      new THREE.Vector3(-1.0, 0.10,  1.2),
      new THREE.Vector3( 0.9, 0.25,  0.2),
      new THREE.Vector3( 2.4, 0.40, -0.8),
      new THREE.Vector3( 0.2, -0.05, -2.2),
      new THREE.Vector3(-2.0, 0.18,  2.1)
    ];

    const endingGeom = new THREE.IcosahedronGeometry(0.18, 1);

    endingPositions.forEach((p, i) => {
      const col = endingColors[i % endingColors.length];

      const mat = new THREE.MeshStandardMaterial({
        color: col,
        emissive: col,
        emissiveIntensity: 0.9,
        roughness: 0.18,
        metalness: 0.05,
        transparent: true,
        opacity: 0.98
      });

      const m = new THREE.Mesh(endingGeom, mat);
      m.position.copy(p);

      // Slightly "sink" them toward the manifold by sampling approx height
      m.position.y += sampleManifoldHeight(p.x, p.z) * 0.35;

      endingsGroup.add(m);

      const spr = makeGlowSprite(col, 1.0, 1.0);
      spr.position.copy(m.position);
      endingsGroup.add(spr);
    });

    // Add faint "embedding volume" haze
    const haze = new THREE.Mesh(
      new THREE.SphereGeometry(3.1, 40, 40),
      new THREE.MeshStandardMaterial({
        color: 0x0e1433,
        transparent: true,
        opacity: 0.08,
        side: THREE.DoubleSide,
        emissive: 0x0b1033,
        emissiveIntensity: 0.4
      })
    );
    haze.position.set(0, 0.8, 0);
    endingsGroup.add(haze);

    // -----------------------------
    // Helpers
    // -----------------------------
    // A quick analytic approximation of the displacement used above.
    function sampleManifoldHeight(x, z) {
      const wave =
        0.55 * Math.sin(0.9 * x) * Math.cos(0.8 * z) +
        0.25 * Math.sin(0.35 * (x + z)) +
        0.18 * Math.cos(0.45 * (x - 1.2 * z));
      const basin = -0.015 * (x * x + z * z);
      return wave + basin + 0.15; // match mesh offset a bit
    }

    function makeGlowSprite(colorHex, sx = 0.7, sy = 0.7) {
      const c = document.createElement("canvas");
      c.width = 128; c.height = 128;
      const ctx = c.getContext("2d");
      const grd = ctx.createRadialGradient(64, 64, 0, 64, 64, 60);
      const col = new THREE.Color(colorHex);
      const rgb = `${Math.floor(col.r * 255)}, ${Math.floor(col.g * 255)}, ${Math.floor(col.b * 255)}`;
      grd.addColorStop(0, `rgba(${rgb}, 0.95)`);
      grd.addColorStop(0.35, `rgba(${rgb}, 0.35)`);
      grd.addColorStop(1, `rgba(${rgb}, 0.0)`);

      ctx.fillStyle = grd;
      ctx.fillRect(0, 0, 128, 128);

      const tex = new THREE.CanvasTexture(c);
      tex.colorSpace = THREE.SRGBColorSpace;

      const mat = new THREE.SpriteMaterial({
        map: tex,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        opacity: 0.9
      });

      const spr = new THREE.Sprite(mat);
      spr.scale.set(sx, sy, 1);
      return spr;
    }

    // -----------------------------
    // Subtle Animation
    // -----------------------------
    let t = 0;

    function animate() {
      requestAnimationFrame(animate);
      controls.update();

      t += 0.006;

      // Slow rotation to give that "gee wiz" parallax
      manifoldGroup.rotation.y = Math.sin(t * 0.25) * 0.06;
      dagGroup.rotation.y      = Math.sin(t * 0.22 + 1.3) * 0.04;

      // Gentle pulsing of ending nodes
      endingsGroup.children.forEach(obj => {
        if (obj.isMesh && obj.geometry && obj.geometry.type.includes("Icosahedron")) {
          const s = 1.0 + 0.05 * Math.sin(t * 2.2 + obj.position.x);
          obj.scale.setScalar(s);
        }
      });

      renderer.render(scene, camera);
    }
    animate();

    // -----------------------------
    // Resize
    // -----------------------------
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
