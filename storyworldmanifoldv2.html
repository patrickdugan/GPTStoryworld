<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Storyworld as a 3-Variable Manifold (V3)</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
html, body {
  margin: 0; padding: 0;
  background: #05060a;
  overflow: hidden;
  font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
}
#ui {
  position: fixed;
  top: 14px; left: 14px;
  color: #dbe2ff;
  font-size: 12px;
  background: rgba(10,14,28,0.55);
  border: 1px solid rgba(140,160,255,0.18);
  padding: 12px 14px;
  border-radius: 12px;
  backdrop-filter: blur(6px);
}
#ui b { color: #ffffff; }
#ui .dim { opacity: 0.75; margin-top: 6px; }
</style>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>
</head>

<body>
<div id="ui">
  <b>Storyworld as a 3-Variable Manifold</b><br/>
  Surface = emergent narrative geometry<br/>
  DAG = encounter / spool structure<br/>
  Nodes = endings as attractors<br/>
  <div class="dim">
    Drag: orbit · Scroll: zoom · Right-drag: pan
  </div>
</div>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";

/* ─────────────────────────────
   Scene / Camera / Renderer
───────────────────────────── */
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x05060a, 0.035);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.outputColorSpace = THREE.SRGBColorSpace;
document.body.appendChild(renderer.domElement);

const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 200);
camera.position.set(0, 8, 18);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

/* ─────────────────────────────
   Lights
───────────────────────────── */
scene.add(new THREE.AmbientLight(0x9aa7ff, 0.25));

const key = new THREE.DirectionalLight(0xffffff, 0.9);
key.position.set(8, 12, 6);
scene.add(key);

/* ─────────────────────────────
   Starfield
───────────────────────────── */
function starfield(n=1200) {
  const g = new THREE.BufferGeometry();
  const p = new Float32Array(n*3);
  for (let i=0;i<n;i++) {
    p[i*3]   = (Math.random()-0.5)*60;
    p[i*3+1] = (Math.random()-0.5)*60;
    p[i*3+2] = (Math.random()-0.5)*60;
  }
  g.setAttribute("position", new THREE.BufferAttribute(p,3));
  return new THREE.Points(g,new THREE.PointsMaterial({
    size:0.06,color:0xaab6ff,opacity:0.6,transparent:true
  }));
}
scene.add(starfield());

/* ─────────────────────────────
   Axes
───────────────────────────── */
const axes = new THREE.AxesHelper(6);
axes.material.opacity = 0.6;
axes.material.transparent = true;
scene.add(axes);

/* ─────────────────────────────
   Manifold Surface
───────────────────────────── */
function manifoldHeight(x,z){
  return (
    0.55*Math.sin(0.9*x)*Math.cos(0.8*z) +
    0.25*Math.sin(0.35*(x+z)) +
    0.18*Math.cos(0.45*(x-1.2*z)) -
    0.015*(x*x+z*z)
  );
}

const size=10, seg=140;
const geo = new THREE.PlaneGeometry(size,size,seg,seg);
geo.rotateX(-Math.PI/2);

const pos = geo.attributes.position;
const colors = [];
for(let i=0;i<pos.count;i++){
  const x=pos.getX(i), z=pos.getZ(i);
  const y=manifoldHeight(x,z);
  pos.setY(i,y);
  const heat = THREE.MathUtils.clamp((y+1.2)/2.4,0,1);
  colors.push(0.15+heat*0.4,0.25+heat*0.4,0.7);
}
geo.setAttribute("color",new THREE.Float32BufferAttribute(colors,3));
geo.computeVertexNormals();

const surface = new THREE.Mesh(
  geo,
  new THREE.MeshStandardMaterial({
    vertexColors:true,
    transparent:true,
    opacity:0.35,
    roughness:0.35,
    emissive:0x0b1235,
    emissiveIntensity:0.35,
    side:THREE.DoubleSide
  })
);
surface.position.y=0.15;
scene.add(surface);

/* ─────────────────────────────
   DAG Structure
───────────────────────────── */
const dag = new THREE.Group(); scene.add(dag);

const dagNodes=[
  [0,1.6,0],
  [-2,1.2,-1],[0,1.1,-1.8],[2,1.2,-1],
  [-2.4,0.7,1],[0,0.6,1.4],[2.4,0.7,1],
  [-1.2,0.2,2.6],[1.2,0.2,2.6]
];

const dagEdges=[[0,1],[0,2],[0,3],[1,4],[2,5],[3,6],[4,7],[5,7],[5,8],[6,8]];

const nodeMeshes=[];
dagNodes.forEach(p=>{
  const m=new THREE.Mesh(
    new THREE.SphereGeometry(0.13,20,20),
    new THREE.MeshStandardMaterial({
      color:0xe8ecff,
      emissive:0x6a86ff,
      emissiveIntensity:0.6
    })
  );
  m.position.set(...p);
  dag.add(m);
  nodeMeshes.push(m);

  const halo=new THREE.Mesh(
    new THREE.RingGeometry(0.17,0.24,32),
    new THREE.MeshBasicMaterial({color:0x8aa2ff,transparent:true,opacity:0.35})
  );
  halo.rotation.x=Math.PI/2;
  halo.position.copy(m.position);
  dag.add(halo);
});

dagEdges.forEach(([a,b])=>{
  const g=new THREE.BufferGeometry().setFromPoints([
    nodeMeshes[a].position,
    nodeMeshes[b].position
  ]);
  dag.add(new THREE.Line(g,new THREE.LineBasicMaterial({
    color:0x8aa2ff,transparent:true,opacity:0.45
  })));
});

/* ─────────────────────────────
   Ending Attractors
───────────────────────────── */
const endings = new THREE.Group(); scene.add(endings);
const endingColors=[0xff6bd6,0x6bffdf,0xffb86b,0x8b6bff,0x6bff7a];
const endingPositions=[
  [-2.4,0.3,-0.6],[-1,0.1,1.2],[1,0.25,0.3],
  [2.4,0.4,-0.8],[0,-0.05,-2.2]
];

endingPositions.forEach((p,i)=>{
  const y=p[1]+manifoldHeight(p[0],p[2])*0.4;
  const m=new THREE.Mesh(
    new THREE.IcosahedronGeometry(0.18,1),
    new THREE.MeshStandardMaterial({
      color:endingColors[i],
      emissive:endingColors[i],
      emissiveIntensity:0.9
    })
  );
  m.position.set(p[0],y,p[2]);
  endings.add(m);
});

/* ─────────────────────────────
   Narrative Trajectories
───────────────────────────── */
const trajGroup=new THREE.Group(); scene.add(trajGroup);

function trajectory(sx,sz){
  const pts=[];
  let x=sx,z=sz;
  for(let i=0;i<40;i++){
    const y=manifoldHeight(x,z)+0.05;
    pts.push(new THREE.Vector3(x,y,z));
    x+=0.14*Math.sin(i*0.5+sx);
    z+=0.14*Math.cos(i*0.5+sz);
  }
  trajGroup.add(new THREE.Line(
    new THREE.BufferGeometry().setFromPoints(pts),
    new THREE.LineBasicMaterial({color:0x9fb0ff,transparent:true,opacity:0.45})
  ));
}
for(let i=0;i<6;i++) trajectory((Math.random()-0.5)*4,(Math.random()-0.5)*4);

/* ─────────────────────────────
   Spool Planes
───────────────────────────── */
function spoolPlane(x,color){
  const p=new THREE.Mesh(
    new THREE.PlaneGeometry(6,6),
    new THREE.MeshStandardMaterial({
      color,transparent:true,opacity:0.12,
      emissive:color,emissiveIntensity:0.15,side:THREE.DoubleSide
    })
  );
  p.position.set(x,1,0);
  p.rotation.y=Math.PI/2;
  return p;
}
scene.add(spoolPlane(-1.6,0x6bffdf));
scene.add(spoolPlane(1.8,0xff6bd6));

/* ─────────────────────────────
   MAS / Diplomacy Agents
───────────────────────────── */
const agents=[];
for(let i=0;i<18;i++){
  const m=new THREE.Mesh(
    new THREE.SphereGeometry(0.05,12,12),
    new THREE.MeshBasicMaterial({color:0xffffff})
  );
  m.userData={
    x:(Math.random()-0.5)*4,
    z:(Math.random()-0.5)*4,
    vx:(Math.random()-0.5)*0.02,
    vz:(Math.random()-0.5)*0.02
  };
  scene.add(m);
  agents.push(m);
}

/* ─────────────────────────────
   Animate
───────────────────────────── */
let t=0;
function animate(){
  requestAnimationFrame(animate);
  t+=0.006;
  surface.rotation.y=Math.sin(t*0.25)*0.06;
  dag.rotation.y=Math.sin(t*0.22+1.2)*0.04;

  agents.forEach(a=>{
    a.userData.x+=a.userData.vx;
    a.userData.z+=a.userData.vz;
    a.position.set(
      a.userData.x,
      manifoldHeight(a.userData.x,a.userData.z)+0.08,
      a.userData.z
    );
  });

  controls.update();
  renderer.render(scene,camera);
}
animate();

window.addEventListener("resize",()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
