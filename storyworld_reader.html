<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Storyworld Reader</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Crimson Text', Georgia, serif;
      background: #0a0a0f;
      color: #e8e4d9;
      min-height: 100vh;
      overflow-x: hidden;
    }

    #three-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
    }

    #app {
      position: relative;
      z-index: 1;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* Loading Screen */
    #loading-screen {
      position: fixed;
      inset: 0;
      background: #0a0a0f;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
      transition: opacity 0.5s ease;
    }

    #loading-screen.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .loader {
      width: 60px;
      height: 60px;
      border: 2px solid rgba(200, 170, 110, 0.2);
      border-top-color: #c8aa6e;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    #loading-screen p {
      margin-top: 20px;
      color: #8a8578;
      font-size: 14px;
      letter-spacing: 2px;
      text-transform: uppercase;
    }

    /* Title Screen */
    #title-screen {
      position: fixed;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 50;
      padding: 40px;
      text-align: center;
      background: linear-gradient(180deg, rgba(10,10,15,0.9) 0%, rgba(10,10,15,0.95) 100%);
    }

    #title-screen.hidden {
      display: none;
    }

    #title-screen h1 {
      font-size: clamp(2rem, 6vw, 4rem);
      font-weight: 400;
      color: #c8aa6e;
      margin-bottom: 30px;
      letter-spacing: 4px;
      text-shadow: 0 0 40px rgba(200, 170, 110, 0.3);
    }

    #title-screen .about {
      max-width: 700px;
      font-size: 1.1rem;
      line-height: 1.8;
      color: #b0a898;
      margin-bottom: 50px;
    }

    .file-drop-zone {
      width: 100%;
      max-width: 500px;
      padding: 60px 40px;
      border: 2px dashed rgba(200, 170, 110, 0.3);
      border-radius: 8px;
      background: rgba(200, 170, 110, 0.03);
      cursor: pointer;
      transition: all 0.3s ease;
      margin-bottom: 30px;
    }

    .file-drop-zone:hover, .file-drop-zone.dragover {
      border-color: #c8aa6e;
      background: rgba(200, 170, 110, 0.08);
    }

    .file-drop-zone p {
      color: #8a8578;
      font-size: 1rem;
    }

    .file-drop-zone input {
      display: none;
    }

    .demo-btn {
      padding: 15px 40px;
      background: transparent;
      border: 1px solid #c8aa6e;
      color: #c8aa6e;
      font-family: inherit;
      font-size: 1rem;
      letter-spacing: 2px;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .demo-btn:hover {
      background: #c8aa6e;
      color: #0a0a0f;
    }

    /* Game Container */
    #game-container {
      display: none;
      flex: 1;
      padding: 20px;
    }

    #game-container.active {
      display: flex;
      flex-direction: column;
    }

    /* Header */
    #game-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 20px;
      background: rgba(10, 10, 15, 0.8);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid rgba(200, 170, 110, 0.2);
    }

    #game-title {
      font-size: 1.1rem;
      color: #c8aa6e;
      letter-spacing: 2px;
    }

    #turn-counter {
      font-size: 0.85rem;
      color: #8a8578;
    }

    /* Main Content */
    #game-main {
      flex: 1;
      display: flex;
      gap: 20px;
      padding: 20px;
      max-width: 1400px;
      margin: 0 auto;
      width: 100%;
    }

    /* Narrative Panel */
    #narrative-panel {
      flex: 2;
      display: flex;
      flex-direction: column;
      background: rgba(10, 10, 15, 0.85);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(200, 170, 110, 0.15);
      border-radius: 4px;
      overflow: hidden;
    }

    #encounter-header {
      padding: 20px 25px;
      border-bottom: 1px solid rgba(200, 170, 110, 0.1);
    }

    #encounter-title {
      font-size: 1.5rem;
      color: #c8aa6e;
      font-weight: 400;
    }

    #encounter-spool {
      font-size: 0.8rem;
      color: #6a6560;
      margin-top: 5px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    #narrative-content {
      flex: 1;
      padding: 25px;
      overflow-y: auto;
    }

    #encounter-image {
      width: 100%;
      max-height: 300px;
      object-fit: cover;
      border-radius: 4px;
      margin-bottom: 20px;
      display: none;
    }

    #encounter-image.visible {
      display: block;
    }

    #encounter-text {
      font-size: 1.1rem;
      line-height: 1.9;
      color: #d4d0c5;
      white-space: pre-wrap;
    }

    #reaction-text {
      margin-top: 25px;
      padding: 20px;
      background: rgba(200, 170, 110, 0.05);
      border-left: 3px solid #c8aa6e;
      font-style: italic;
      color: #b8b4a8;
      display: none;
    }

    #reaction-text.visible {
      display: block;
    }

    /* Options Panel */
    #options-panel {
      padding: 20px 25px;
      border-top: 1px solid rgba(200, 170, 110, 0.1);
      background: rgba(0, 0, 0, 0.2);
    }

    #options-list {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .option-btn {
      padding: 15px 20px;
      background: rgba(200, 170, 110, 0.05);
      border: 1px solid rgba(200, 170, 110, 0.2);
      border-radius: 4px;
      color: #d4d0c5;
      font-family: inherit;
      font-size: 1rem;
      text-align: left;
      cursor: pointer;
      transition: all 0.2s ease;
      line-height: 1.5;
    }

    .option-btn:hover {
      background: rgba(200, 170, 110, 0.12);
      border-color: #c8aa6e;
      color: #e8e4d9;
    }

    .option-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .continue-btn {
      padding: 15px 30px;
      background: #c8aa6e;
      border: none;
      color: #0a0a0f;
      font-family: inherit;
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.2s ease;
      letter-spacing: 1px;
    }

    .continue-btn:hover {
      background: #ddc07a;
    }

    /* Stats Panel */
    #stats-panel {
      flex: 1;
      max-width: 320px;
      background: rgba(10, 10, 15, 0.85);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(200, 170, 110, 0.15);
      border-radius: 4px;
      padding: 20px;
      overflow-y: auto;
      max-height: calc(100vh - 140px);
    }

    .stats-section {
      margin-bottom: 25px;
    }

    .stats-section h3 {
      font-size: 0.8rem;
      color: #8a8578;
      text-transform: uppercase;
      letter-spacing: 2px;
      margin-bottom: 15px;
      padding-bottom: 8px;
      border-bottom: 1px solid rgba(200, 170, 110, 0.1);
    }

    .stat-row {
      margin-bottom: 12px;
    }

    .stat-label {
      display: flex;
      justify-content: space-between;
      font-size: 0.85rem;
      color: #a8a498;
      margin-bottom: 5px;
    }

    .stat-bar {
      height: 6px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 3px;
      overflow: hidden;
      position: relative;
    }

    .stat-bar-fill {
      position: absolute;
      top: 0;
      height: 100%;
      border-radius: 3px;
      transition: all 0.5s ease;
    }

    .stat-bar-negative {
      right: 50%;
      background: linear-gradient(90deg, #8b6914, #c8aa6e);
    }

    .stat-bar-positive {
      left: 50%;
      background: linear-gradient(90deg, #c8aa6e, #e8d08a);
    }

    .stat-bar-center {
      position: absolute;
      left: 50%;
      top: -2px;
      bottom: -2px;
      width: 2px;
      background: rgba(200, 170, 110, 0.3);
      transform: translateX(-50%);
    }

    /* Character tabs */
    .char-tabs {
      display: flex;
      gap: 5px;
      margin-bottom: 15px;
      flex-wrap: wrap;
    }

    .char-tab {
      padding: 6px 12px;
      background: rgba(200, 170, 110, 0.08);
      border: 1px solid rgba(200, 170, 110, 0.15);
      border-radius: 3px;
      color: #8a8578;
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .char-tab:hover, .char-tab.active {
      background: rgba(200, 170, 110, 0.15);
      border-color: #c8aa6e;
      color: #c8aa6e;
    }

    /* History */
    #history-section {
      max-height: 200px;
      overflow-y: auto;
    }

    .history-item {
      padding: 8px 0;
      border-bottom: 1px solid rgba(200, 170, 110, 0.05);
      font-size: 0.8rem;
      color: #6a6560;
    }

    .history-item:last-child {
      border-bottom: none;
    }

    /* Ending screen */
    #ending-overlay {
      position: fixed;
      inset: 0;
      background: rgba(10, 10, 15, 0.95);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 60;
      padding: 40px;
    }

    #ending-overlay.visible {
      display: flex;
    }

    #ending-content {
      max-width: 700px;
      text-align: center;
    }

    #ending-content h2 {
      font-size: 2rem;
      color: #c8aa6e;
      margin-bottom: 30px;
    }

    #ending-content p {
      font-size: 1.1rem;
      line-height: 1.8;
      color: #b0a898;
      margin-bottom: 40px;
    }

    /* Scrollbar */
    ::-webkit-scrollbar {
      width: 6px;
    }

    ::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.2);
    }

    ::-webkit-scrollbar-thumb {
      background: rgba(200, 170, 110, 0.3);
      border-radius: 3px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: rgba(200, 170, 110, 0.5);
    }

    /* Responsive */
    @media (max-width: 900px) {
      #game-main {
        flex-direction: column;
      }

      #stats-panel {
        max-width: none;
        max-height: none;
      }
    }
  </style>
</head>
<body>
  <div id="three-container"></div>

  <div id="app">
    <div id="loading-screen">
      <div class="loader"></div>
      <p>Loading</p>
    </div>

    <div id="title-screen">
      <h1 id="sw-title">Storyworld Reader</h1>
      <p class="about" id="sw-about">Load a storyworld JSON file to begin your journey.</p>
      
      <div class="file-drop-zone" id="file-drop">
        <p>Drop storyworld JSON here or click to browse</p>
        <input type="file" id="file-input" accept=".json">
      </div>

      <button class="demo-btn" id="demo-btn" style="display: none;">Load Demo Storyworld</button>
    </div>

    <div id="game-container">
      <header id="game-header">
        <div id="game-title">—</div>
        <div id="turn-counter">Turn 1</div>
      </header>

      <main id="game-main">
        <section id="narrative-panel">
          <div id="encounter-header">
            <h2 id="encounter-title">—</h2>
            <div id="encounter-spool">—</div>
          </div>

          <div id="narrative-content">
            <img id="encounter-image" src="" alt="Scene illustration">
            <div id="encounter-text"></div>
            <div id="reaction-text"></div>
          </div>

          <div id="options-panel">
            <div id="options-list"></div>
          </div>
        </section>

        <aside id="stats-panel">
          <div class="stats-section">
            <h3>Character</h3>
            <div class="char-tabs" id="char-tabs"></div>
            <div id="char-stats"></div>
          </div>

          <div class="stats-section">
            <h3>History</h3>
            <div id="history-section"></div>
          </div>
        </aside>
      </main>
    </div>

    <div id="ending-overlay">
      <div id="ending-content">
        <h2 id="ending-title">The End</h2>
        <p id="ending-text"></p>
        <button class="demo-btn" id="restart-btn">Begin Again</button>
      </div>
    </div>
  </div>

  <script>
    // ========== THREE.JS BACKGROUND ==========
    const threeContainer = document.getElementById('three-container');
    let scene, camera, renderer, particles, clock;
    let mouseX = 0, mouseY = 0;

    function initThree() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 50;

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      threeContainer.appendChild(renderer.domElement);

      clock = new THREE.Clock();

      // Particle system
      const particleCount = 2000;
      const positions = new Float32Array(particleCount * 3);
      const colors = new Float32Array(particleCount * 3);
      const sizes = new Float32Array(particleCount);

      for (let i = 0; i < particleCount; i++) {
        const i3 = i * 3;
        positions[i3] = (Math.random() - 0.5) * 200;
        positions[i3 + 1] = (Math.random() - 0.5) * 200;
        positions[i3 + 2] = (Math.random() - 0.5) * 100 - 20;

        // Gold/amber colors
        const brightness = 0.3 + Math.random() * 0.7;
        colors[i3] = 0.78 * brightness;
        colors[i3 + 1] = 0.67 * brightness;
        colors[i3 + 2] = 0.43 * brightness;

        sizes[i] = Math.random() * 2 + 0.5;
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

      const material = new THREE.PointsMaterial({
        size: 1.5,
        vertexColors: true,
        transparent: true,
        opacity: 0.6,
        blending: THREE.AdditiveBlending,
        sizeAttenuation: true
      });

      particles = new THREE.Points(geometry, material);
      scene.add(particles);

      // Mouse movement
      document.addEventListener('mousemove', (e) => {
        mouseX = (e.clientX / window.innerWidth - 0.5) * 2;
        mouseY = (e.clientY / window.innerHeight - 0.5) * 2;
      });

      window.addEventListener('resize', onWindowResize);
      animate();
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      
      const time = clock.getElapsedTime();
      
      // Rotate particles slowly
      particles.rotation.y = time * 0.02 + mouseX * 0.1;
      particles.rotation.x = Math.sin(time * 0.01) * 0.1 + mouseY * 0.05;

      // Subtle wave motion
      const positions = particles.geometry.attributes.position.array;
      for (let i = 0; i < positions.length; i += 3) {
        positions[i + 1] += Math.sin(time + positions[i] * 0.01) * 0.002;
      }
      particles.geometry.attributes.position.needsUpdate = true;

      renderer.render(scene, camera);
    }

    initThree();

    // ========== STORYWORLD ENGINE ==========
    class StoryworldEngine {
      constructor() {
        this.storyworld = null;
        this.state = {
          turn: 1,
          currentEncounterId: null,
          characters: {},
          history: [],
          visitedEncounters: new Set(),
          pendingReaction: null
        };
        this.imageMap = new Map(); // encounter_id -> image URL
      }

      load(data) {
        this.storyworld = data;
        this.reset();
        return this;
      }

      reset() {
        if (!this.storyworld) return;

        this.state = {
          turn: 1,
          currentEncounterId: null,
          characters: {},
          history: [],
          visitedEncounters: new Set(),
          pendingReaction: null
        };

        // Initialize character states
        for (const char of this.storyworld.characters) {
          this.state.characters[char.id] = {
            name: char.name,
            properties: { ...char.bnumber_properties }
          };
        }

        // Find first encounter
        const firstSpool = this.storyworld.spools.find(s => s.starts_active);
        if (firstSpool && firstSpool.encounters.length > 0) {
          this.state.currentEncounterId = firstSpool.encounters[0];
        }
      }

      setImage(encounterId, imageUrl) {
        this.imageMap.set(encounterId, imageUrl);
      }

      getCurrentEncounter() {
        if (!this.state.currentEncounterId) return null;
        return this.storyworld.encounters.find(e => e.id === this.state.currentEncounterId);
      }

      getEncounterSpool(encounterId) {
        for (const spool of this.storyworld.spools) {
          if (spool.encounters.includes(encounterId)) {
            return spool.spool_name;
          }
        }
        return null;
      }

      getEncounterImage(encounterId) {
        // Check custom image map first
        if (this.imageMap.has(encounterId)) {
          return this.imageMap.get(encounterId);
        }
        // Check encounter for image field
        const encounter = this.storyworld.encounters.find(e => e.id === encounterId);
        if (encounter && encounter.image) {
          return encounter.image;
        }
        return null;
      }

      getText(script) {
        if (!script) return '';
        if (typeof script === 'string') return script;
        if (script.value !== undefined) return script.value;
        return '';
      }

      getVisibleOptions(encounter) {
        if (!encounter || !encounter.options) return [];
        return encounter.options.filter(opt => {
          // For now, treat all options as visible if visibility_script is true or missing
          return opt.visibility_script === true || opt.visibility_script === undefined;
        });
      }

      selectOption(optionId) {
        const encounter = this.getCurrentEncounter();
        if (!encounter) return null;

        const option = encounter.options.find(o => o.id === optionId);
        if (!option || !option.reactions || option.reactions.length === 0) return null;

        // Select first reaction (or could implement weighted selection)
        const reaction = option.reactions[0];

        // Apply effects
        if (reaction.after_effects) {
          this.applyEffects(reaction.after_effects);
        }

        // Record history
        this.state.history.push({
          turn: this.state.turn,
          encounter: encounter.title,
          choice: this.getText(option.text_script)
        });

        // Store reaction for display
        this.state.pendingReaction = {
          text: this.getText(reaction.text_script),
          nextEncounterId: reaction.consequence_id
        };

        return this.state.pendingReaction;
      }

      continueToNext() {
        if (!this.state.pendingReaction) return null;

        const nextId = this.state.pendingReaction.nextEncounterId;
        this.state.pendingReaction = null;

        if (nextId) {
          this.state.currentEncounterId = nextId;
          this.state.visitedEncounters.add(nextId);
          this.state.turn++;
        }

        return this.getCurrentEncounter();
      }

      applyEffects(effects) {
        for (const effect of effects) {
          if (effect.effect_type === 'Bounded Number Effect') {
            this.applyBNumberEffect(effect);
          }
        }
      }

      applyBNumberEffect(effect) {
        const setPointer = effect.Set;
        if (!setPointer) return;

        const charId = setPointer.character;
        const propName = setPointer.keyring?.[0];
        if (!charId || !propName) return;

        const char = this.state.characters[charId];
        if (!char || char.properties[propName] === undefined) return;

        const toExpr = effect.to;
        if (toExpr?.operator_type === 'Nudge') {
          const operands = toExpr.operands || [];
          const currentVal = char.properties[propName];
          const nudgeAmount = operands[1]?.value || 0;
          
          // Nudge formula: moves toward +1 or -1 asymptotically
          const newVal = this.nudge(currentVal, nudgeAmount);
          char.properties[propName] = newVal;
        }
      }

      nudge(current, amount) {
        // Asymptotic nudge toward bounds
        if (amount > 0) {
          return current + amount * (1 - current);
        } else {
          return current + amount * (1 + current);
        }
      }

      isEnding(encounterId) {
        const endingSpool = this.storyworld.spools.find(s => 
          s.spool_name.toLowerCase().includes('ending') || s.id.includes('ending')
        );
        if (endingSpool) {
          return endingSpool.encounters.includes(encounterId);
        }
        // Also check if encounter has no options or no consequence
        const encounter = this.storyworld.encounters.find(e => e.id === encounterId);
        return encounter && (!encounter.options || encounter.options.length === 0);
      }
    }

    // ========== UI CONTROLLER ==========
    const engine = new StoryworldEngine();

    const elements = {
      loadingScreen: document.getElementById('loading-screen'),
      titleScreen: document.getElementById('title-screen'),
      swTitle: document.getElementById('sw-title'),
      swAbout: document.getElementById('sw-about'),
      fileDrop: document.getElementById('file-drop'),
      fileInput: document.getElementById('file-input'),
      demoBtn: document.getElementById('demo-btn'),
      gameContainer: document.getElementById('game-container'),
      gameTitle: document.getElementById('game-title'),
      turnCounter: document.getElementById('turn-counter'),
      encounterTitle: document.getElementById('encounter-title'),
      encounterSpool: document.getElementById('encounter-spool'),
      encounterImage: document.getElementById('encounter-image'),
      encounterText: document.getElementById('encounter-text'),
      reactionText: document.getElementById('reaction-text'),
      optionsList: document.getElementById('options-list'),
      charTabs: document.getElementById('char-tabs'),
      charStats: document.getElementById('char-stats'),
      historySection: document.getElementById('history-section'),
      endingOverlay: document.getElementById('ending-overlay'),
      endingTitle: document.getElementById('ending-title'),
      endingText: document.getElementById('ending-text'),
      restartBtn: document.getElementById('restart-btn')
    };

    let selectedCharId = null;

    // File handling
    elements.fileDrop.addEventListener('click', () => elements.fileInput.click());
    elements.fileDrop.addEventListener('dragover', (e) => {
      e.preventDefault();
      elements.fileDrop.classList.add('dragover');
    });
    elements.fileDrop.addEventListener('dragleave', () => {
      elements.fileDrop.classList.remove('dragover');
    });
    elements.fileDrop.addEventListener('drop', (e) => {
      e.preventDefault();
      elements.fileDrop.classList.remove('dragover');
      const file = e.dataTransfer.files[0];
      if (file) loadFile(file);
    });
    elements.fileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) loadFile(file);
    });

    function loadFile(file) {
      elements.loadingScreen.classList.remove('hidden');
      
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = JSON.parse(e.target.result);
          startGame(data);
        } catch (err) {
          alert('Failed to parse storyworld JSON: ' + err.message);
          elements.loadingScreen.classList.add('hidden');
        }
      };
      reader.readAsText(file);
    }

    function startGame(data) {
      engine.load(data);
      
      elements.gameTitle.textContent = data.title || 'Storyworld';
      selectedCharId = data.characters[0]?.id || null;

      elements.loadingScreen.classList.add('hidden');
      elements.titleScreen.classList.add('hidden');
      elements.gameContainer.classList.add('active');

      renderCharTabs();
      renderEncounter();
    }

    function renderEncounter() {
      const encounter = engine.getCurrentEncounter();
      if (!encounter) return;

      elements.turnCounter.textContent = `Turn ${engine.state.turn}`;
      elements.encounterTitle.textContent = encounter.title || 'Untitled';
      elements.encounterSpool.textContent = engine.getEncounterSpool(encounter.id) || '';
      elements.encounterText.textContent = engine.getText(encounter.text_script);

      // Image handling
      const imageUrl = engine.getEncounterImage(encounter.id);
      if (imageUrl) {
        elements.encounterImage.src = imageUrl;
        elements.encounterImage.classList.add('visible');
      } else {
        elements.encounterImage.classList.remove('visible');
      }

      // Hide reaction text
      elements.reactionText.classList.remove('visible');

      // Render options
      renderOptions(encounter);
      renderStats();
      renderHistory();

      // Check for ending
      if (engine.isEnding(encounter.id)) {
        const options = engine.getVisibleOptions(encounter);
        if (options.length === 0) {
          showEnding(encounter);
        }
      }
    }

    function renderOptions(encounter) {
      const options = engine.getVisibleOptions(encounter);
      elements.optionsList.innerHTML = '';

      if (engine.state.pendingReaction) {
        // Show continue button
        const btn = document.createElement('button');
        btn.className = 'continue-btn';
        btn.textContent = 'Continue';
        btn.onclick = () => {
          engine.continueToNext();
          renderEncounter();
        };
        elements.optionsList.appendChild(btn);
        return;
      }

      for (const opt of options) {
        const btn = document.createElement('button');
        btn.className = 'option-btn';
        btn.textContent = engine.getText(opt.text_script);
        btn.onclick = () => selectOption(opt.id);
        elements.optionsList.appendChild(btn);
      }
    }

    function selectOption(optionId) {
      const reaction = engine.selectOption(optionId);
      if (reaction) {
        elements.reactionText.textContent = reaction.text;
        elements.reactionText.classList.add('visible');
        
        // Re-render to show continue button
        renderOptions(engine.getCurrentEncounter());
        renderStats();
      }
    }

    function renderCharTabs() {
      elements.charTabs.innerHTML = '';
      
      for (const char of engine.storyworld.characters) {
        const tab = document.createElement('button');
        tab.className = 'char-tab' + (char.id === selectedCharId ? ' active' : '');
        tab.textContent = char.name;
        tab.onclick = () => {
          selectedCharId = char.id;
          document.querySelectorAll('.char-tab').forEach(t => t.classList.remove('active'));
          tab.classList.add('active');
          renderStats();
        };
        elements.charTabs.appendChild(tab);
      }
    }

    function renderStats() {
      if (!selectedCharId) return;
      
      const char = engine.state.characters[selectedCharId];
      if (!char) return;

      const props = engine.storyworld.authored_properties.filter(p => !p.property_name.startsWith('p'));
      
      let html = '';
      for (const prop of props) {
        const value = char.properties[prop.property_name] || 0;
        const pValue = char.properties['p' + prop.property_name] || 0;
        
        const displayName = prop.property_name.replace(/_/g, ' ');
        const percentage = ((value + 1) / 2) * 100;
        
        html += `
          <div class="stat-row">
            <div class="stat-label">
              <span>${displayName}</span>
              <span>${value.toFixed(3)}</span>
            </div>
            <div class="stat-bar">
              <div class="stat-bar-center"></div>
              ${value < 0 
                ? `<div class="stat-bar-negative" style="width: ${Math.abs(value) * 50}%"></div>`
                : `<div class="stat-bar-positive" style="width: ${value * 50}%"></div>`
              }
            </div>
          </div>
        `;
      }

      elements.charStats.innerHTML = html;
    }

    function renderHistory() {
      const history = engine.state.history.slice(-10).reverse();
      
      let html = '';
      for (const item of history) {
        html += `
          <div class="history-item">
            <strong>Turn ${item.turn}:</strong> ${item.encounter}<br>
            <em>"${item.choice.substring(0, 60)}${item.choice.length > 60 ? '...' : ''}"</em>
          </div>
        `;
      }

      elements.historySection.innerHTML = html || '<p style="color: #6a6560; font-size: 0.85rem;">No history yet.</p>';
    }

    function showEnding(encounter) {
      setTimeout(() => {
        elements.endingTitle.textContent = encounter.title || 'The End';
        elements.endingText.textContent = engine.getText(encounter.text_script);
        elements.endingOverlay.classList.add('visible');
      }, 1000);
    }

    elements.restartBtn.addEventListener('click', () => {
      engine.reset();
      elements.endingOverlay.classList.remove('visible');
      renderEncounter();
    });

    // Hide loading screen after init
    setTimeout(() => {
      elements.loadingScreen.classList.add('hidden');
    }, 500);

    // ========== IMAGE ASSIGNMENT API ==========
    // Call this to assign an image to an encounter:
    // engine.setImage('page_decree', 'https://example.com/image.jpg');
    // Or add "image" field to encounter in JSON

    // Expose for console usage
    window.engine = engine;
    window.setEncounterImage = (encounterId, imageUrl) => engine.setImage(encounterId, imageUrl);
  </script>
</body>
</html>
